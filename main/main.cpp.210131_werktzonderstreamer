/* baswi
* main stacksize increased to 32K?
*/

/**
 * 2. Kconfig setup
 * 
 * If you have a Kconfig file, copy the content from
 *  https://github.com/espressif/esp32-camera/blob/master/Kconfig into it.
 * In case you haven't, copy and paste this Kconfig file inside the src directory.
 * This Kconfig file has definitions that allows more control over the camera and
 * how it will be initialized.
 */

/**
 * 3. Enable PSRAM on sdkconfig:
 * 
 * CONFIG_ESP32_SPIRAM_SUPPORT=y
 * 
 * More info on
 * https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/kconfig.html#config-esp32-spiram-support
 *


BASWI specific
Streaming webserver code copied en bewerkt from: https://github.com/jameszah/ESP32-CAM-Video-Recorder-junior/blob/master/ESP32-CAM-Video-Recorder-junior-10x.ino


*/
// ================================ CODE ======================================

#include <esp_event_loop.h>
#define LOG_LOCAL_LEVEL ESP_LOG_VERBOSE
#include <esp_log.h>
#include <esp_system.h>
#include <nvs_flash.h>
#include <sys/param.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "esp_camera.h"
#include <stdio.h>
#include <cstring>
//#include <string> //without .h; standard C++ lib

#include "esp_wifi.h"
#include "esp_event_loop.h"
#include "freertos/event_groups.h"

#include "esp_http_client.h"
#include "protocol_examples_common.h"
#include "esp_tls.h"
#include "esp_http_server.h"
#include "time.h"
#include "esp_sntp.h"

// Custom libraries
//#include "utlgbotlib.h"
// Telegram Bot Token (Get from Botfather)
#define TLG_TOKEN "1408233833:AAF-sXSWU9OrpKfVBB0eP8l7NiAeukizk9I"
//uTLGBot Bot(TLG_TOKEN);

//baswi pins for TTGO T-camera
#define CAM_PIN_PWDN    -1 //power down is not used
#define CAM_PIN_RESET   -1 //software reset will be performed
#define CAM_PIN_XCLK    4
#define CAM_PIN_SIOD    18
#define CAM_PIN_SIOC    23

#define CAM_PIN_D7      36
#define CAM_PIN_D6      37
#define CAM_PIN_D5      38
#define CAM_PIN_D4      39
#define CAM_PIN_D3      35
#define CAM_PIN_D2      14
#define CAM_PIN_D1      13
#define CAM_PIN_D0      34
#define CAM_PIN_VSYNC   5
#define CAM_PIN_HREF    27
#define CAM_PIN_PCLK    25

#define BUTTON_GPIO GPIO_NUM_15
#define PIR_PIN GPIO_NUM_19 //PIR cannot wake device, button can
#define BUTTON_PRESSED 1 //value put in gpio_queue when button interrupt occurs
#define PIR_ACTIVATED  2 //value put in gpio_queue when PIR interrupt occurs

static const char *TAG = "***";
static void obtain_time(void);
static void initialize_sntp(void);
time_t now;
char localip[20];

void time_sync_notification_cb(struct timeval *tv)
{
    ESP_LOGI(TAG, "Notification of a time synchronization event");
}


static camera_config_t camera_config = {
    .pin_pwdn = CAM_PIN_PWDN,
    .pin_reset = CAM_PIN_RESET,
    .pin_xclk = CAM_PIN_XCLK,
    .pin_sscb_sda = CAM_PIN_SIOD,
    .pin_sscb_scl = CAM_PIN_SIOC,

    .pin_d7 = CAM_PIN_D7,
    .pin_d6 = CAM_PIN_D6,
    .pin_d5 = CAM_PIN_D5,
    .pin_d4 = CAM_PIN_D4,
    .pin_d3 = CAM_PIN_D3,
    .pin_d2 = CAM_PIN_D2,
    .pin_d1 = CAM_PIN_D1,
    .pin_d0 = CAM_PIN_D0,
    .pin_vsync = CAM_PIN_VSYNC,
    .pin_href = CAM_PIN_HREF,
    .pin_pclk = CAM_PIN_PCLK,

    //XCLK 20MHz or 10MHz for OV2640 double FPS (Experimental)
    .xclk_freq_hz = 20000000,
    .ledc_timer = LEDC_TIMER_0,
    .ledc_channel = LEDC_CHANNEL_0,

    .pixel_format = PIXFORMAT_JPEG, //YUV422,GRAYSCALE,RGB565,JPEG
    .frame_size = FRAMESIZE_VGA,    //QQVGA-UXGA Do not use sizes above QVGA when not JPEG
//    .frame_size = FRAMESIZE_UXGA,    //QQVGA-UXGA Do not use sizes above QVGA when not JPEG
                                     //UXGA Works in separate streamer_stable; doorbell->getting fb not on time oid
    .jpeg_quality = 12, //0-63 lower number means higher quality, was 12
    .fb_count = 1       //if more than one, i2s runs in continuous mode. Use only with JPEG
};

bool wifi_has_ip = false;
bool sendAlert2Telegram = false;

//esp_err_t _http_event_handler(esp_http_client_event_t *evt); //forward declaration
//esp_http_client_handle_t http_client; //initialised in main
#define MAX_HTTP_OUTPUT_BUFFER 2048 
//char http_response_buffer[MAX_HTTP_OUTPUT_BUFFER] = {0};
//esp_http_client_config_t http_config = { //if this var is global, it should not be cleanedup
//    .host = "api.telegram.org",
//    .path = "/bot",
//    .query = "esp",
//    .event_handler = _http_event_handler,
//    .user_data = http_response_buffer,        // Pass address of global buffer to get response; baswi made buffer global to avoid stack overflow
//  };
  
#define POST_DATA_LENGTH 2048
  

camera_fb_t * fb_next = NULL;
uint8_t* framebuffer;
int framebuffer_len;
float most_recent_fps = 0;
int most_recent_avg_framesize = 0;
static const char devname[] = "videodoorbell"; // name of your camera for mDNS, Router, and filenames
static const char vernum[] = "v10";
int c1_framesize = 7;                //  10 UXGA, 9 SXGA, 7 SVGA, 6 VGA, 5 CIF
int c1_quality = 10;                 //  quality on the 1..63 scale  - lower is better quality and bigger files - must be higher than the jpeg_quality in camera_config
int c1_avi_length = 1800;            // how long a movie in seconds -- 1800 sec = 30 min

int c2_framesize = 10;
int c2_quality = 10;
int c2_avi_length = 1800;

int c1_or_c2 = 1;
int framesize = c1_framesize;
int quality = c1_quality;
int avi_length = c1_avi_length;

// begin deboucing definitions
#define DEBOUNCETIME_BUTTON 400 //msec
#define DEBOUNCETIME_PIR 10000 //10 sec; don't send PIR events within 10 seconds

// volatile removed - not changed anymore in ISR; volatile prevents compiler optimisation
//DEL uint32_t lastTimeButtonPressed = 0; 
//DEL uint32_t lastTimePIRActivated = 0; 

//DE uint32_t currentTime = 0;
// baswi - end debouncing definitions

static xQueueHandle gpio_evt_button_queue = NULL; //used for button interrupts
static xQueueHandle gpio_evt_PIR_queue = NULL; //used for PIR interrupts

DRAM_ATTR const uint32_t button_pressed = (uint32_t) BUTTON_PRESSED; //baswi  value put in queue 201229: inserted DRAM_ATTR const
static void IRAM_ATTR handleButtonInterrupt() {
// Interrupt Service Routine - Keep it short!
//   201212 do not get time and set var's; only put something in queue, otherweise WDG expires
//   201229 ISR may only call functions placed into IRAM or functions present in ROM   
    gpio_intr_disable(BUTTON_GPIO); //disable inter to prevent lot of bouncing inter
    xQueueSendFromISR(gpio_evt_button_queue, &button_pressed, NULL);
}

DRAM_ATTR const uint32_t PIR_activated = (uint32_t) 2; //baswi value put in queue 201229: inserted DRAM_ATTR const
static void IRAM_ATTR handlePIRInterrupt() {
//   201229 ISR may only call functions placed into IRAM or functions present in ROM
    gpio_intr_disable(PIR_PIN); //disable inter to prevent lot of PIR interrupts
    xQueueSendFromISR(gpio_evt_PIR_queue, &PIR_activated, NULL);
}


static esp_err_t init_camera()
{
    //initialize the camera
    esp_err_t err = esp_camera_init(&camera_config);
    if (err != ESP_OK)
    {
        ESP_LOGE(TAG, "Camera Init Failed");
        return err;
    }
    return ESP_OK;
}

//baswi: tested; extern C is necessary, to prevent reference not found linker errors
extern "C" {
//    #include "IDF_Oled.h"
    #include "ssd1306.h"
}

#define SSID "netwerk2"
#define PASSPHARSE "@@@"

static EventGroupHandle_t wifi_event_group;
const int CONNECTED_BIT = BIT0;

void wifi_connect(){
    wifi_config_t cfg = {}; // must zero the structure, otherwise connect fails 

    strcpy((char *) cfg.sta.ssid, SSID);
    strcpy((char *) cfg.sta.password, PASSPHARSE);

    ESP_ERROR_CHECK( esp_wifi_disconnect() );
    ESP_ERROR_CHECK( esp_wifi_set_config(ESP_IF_WIFI_STA, &cfg) );
    ESP_ERROR_CHECK( esp_wifi_connect() );
}

static esp_err_t event_handler(void *ctx, system_event_t *event)
{
    switch(event->event_id) {
    case SYSTEM_EVENT_STA_START:
        wifi_connect();
        break;
    case SYSTEM_EVENT_STA_GOT_IP:
        xEventGroupSetBits(wifi_event_group, CONNECTED_BIT);
        wifi_has_ip = true;
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        esp_wifi_connect();
        xEventGroupClearBits(wifi_event_group, CONNECTED_BIT);
        break;
    default:
        break;
    }
    return ESP_OK;
}

static void initialise_wifi(void)
{
    //esp_log_level_set("wifi", ESP_LOG_NONE); // disable wifi driver logging
    tcpip_adapter_init();
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK( esp_wifi_init(&cfg) );
    ESP_ERROR_CHECK( esp_wifi_set_mode(WIFI_MODE_STA) );
    ESP_ERROR_CHECK( esp_wifi_start() );
    esp_err_t ret = tcpip_adapter_set_hostname(TCPIP_ADAPTER_IF_STA ,"icircuit");
    if(ret != ESP_OK ){
      ESP_LOGE(TAG,"failed to set hostname:%d",ret);  
    }
}

// ***WIFI END

/*esp_err_t _http_event_handler(esp_http_client_event_t *evt)
{
    static char *output_buffer;  // Buffer to store response of http request from event handler
    static int output_len;       // Stores number of bytes read
    switch(evt->event_id) {
        case HTTP_EVENT_ERROR:
            ESP_LOGD(TAG, "HTTP_EVENT_ERROR");
            break;
        case HTTP_EVENT_ON_CONNECTED:
            ESP_LOGD(TAG, "HTTP_EVENT_ON_CONNECTED");
            break;
        case HTTP_EVENT_HEADER_SENT:
            ESP_LOGD(TAG, "HTTP_EVENT_HEADER_SENT");
            break;
        case HTTP_EVENT_ON_HEADER:
            ESP_LOGD(TAG, "HTTP_EVENT_ON_HEADER, key=%s, value=%s", evt->header_key, evt->header_value);
            break;
        case HTTP_EVENT_ON_DATA:
            ESP_LOGD(TAG, "HTTP_EVENT_ON_DATA, len=%d", evt->data_len);
            //
            //  Check for chunked encoding is added as the URL for chunked encoding used in this example returns binary data.
            //  However, event handler can also be used in case chunked encoding is used.
            //
            if (!esp_http_client_is_chunked_response(evt->client)) {
                // If user_data buffer is configured, copy the response into the buffer
                if (evt->user_data) {
                    memcpy(evt->user_data + output_len, evt->data, evt->data_len);
                } else {
                    if (output_buffer == NULL) {
                        output_buffer = (char *) malloc(esp_http_client_get_content_length(evt->client));
                        output_len = 0;
                        if (output_buffer == NULL) {
                            ESP_LOGE(TAG, "Failed to allocate memory for output buffer");
                            return ESP_FAIL;
                        }
                    }
                    memcpy(output_buffer + output_len, evt->data, evt->data_len);
                }
                output_len += evt->data_len;
            }

            break;
        case HTTP_EVENT_ON_FINISH:
            ESP_LOGD(TAG, "HTTP_EVENT_ON_FINISH");
            if (output_buffer != NULL) {
                // Response is accumulated in output_buffer. Uncomment the below line to print the accumulated response
                ESP_LOG_BUFFER_HEX(TAG, output_buffer, output_len);
                free(output_buffer);
                output_buffer = NULL;
                output_len = 0;
            }
            break;
        case HTTP_EVENT_DISCONNECTED:
            ESP_LOGI(TAG, "HTTP_EVENT_DISCONNECTED");
            int mbedtls_err = 0;
            esp_err_t err = esp_tls_get_and_clear_last_error((esp_tls_last_error*)evt->data, &mbedtls_err, NULL);
            if (err != 0) {
                if (output_buffer != NULL) {
                    free(output_buffer);
                    output_buffer = NULL;
                    output_len = 0;
                }
                ESP_LOGI(TAG, "Last esp error code: 0x%x", err);
                ESP_LOGI(TAG, "Last mbedtls failure: 0x%x", mbedtls_err);
            }
            break;
    }
    return ESP_OK;
}
*/


static void task_sendAlert2Telegram(void *ignore) {
  for (;;) {
    if (sendAlert2Telegram == true) { //@@@could also be implemented via queue event; is that better?
      ESP_LOGI(TAG, "***sendalert2telegram = TRUE");
      char output_buffer[MAX_HTTP_OUTPUT_BUFFER] = {0};   // Buffer to store response of http request
      int content_length = 0;
      esp_http_client_config_t config = {
        .url = "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendDocument?chat_id=573364432",
        //only used in the GET below
      };
      esp_http_client_handle_t client = esp_http_client_init(&config);
      esp_err_t err;

      // GET Request
      // baswi: the uncommented lines are really neccesary, otherwise I get no response on my POST message below
      //        I really don't understand why
      //        Behaviour is the same for httpbin.org and api.telegram.org
      esp_http_client_set_method(client, HTTP_METHOD_GET);
      err = esp_http_client_open(client, 0);
      if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to open HTTP connection: %s", esp_err_to_name(err));
      } else {
        content_length = esp_http_client_fetch_headers(client);
        if (content_length < 0) {
            ESP_LOGE(TAG, "HTTP client fetch headers failed");
        } else {
          int data_read = esp_http_client_read_response(client, output_buffer, MAX_HTTP_OUTPUT_BUFFER);
          if (data_read >= 0) {
            ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %d",
              esp_http_client_get_status_code(client),
              esp_http_client_get_content_length(client));
            //ESP_LOG_BUFFER_HEX(TAG, output_buffer, strlen(output_buffer));
            } else {
              ESP_LOGE(TAG, "Failed to read response");
            }
        }
        esp_http_client_close(client); 
      }

      camera_fb_t * fb = NULL; //get photo
      fb = esp_camera_fb_get();  
      if(!fb) {
        ESP_LOGE(TAG, "Camera capture failed");
        return;
      }
      ESP_LOGI(TAG, "framebuffer has size: %d", fb->len);

      const char* BOTtoken = "bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI";  // your Bot Token (Get from Botfather)
      // Use @myidbot to find out the chat ID of an individual or a group
      // Also note that you need to click "start" on a bot before it can
      // message you
      const char* CHAT_ID = "573364432";

      char post_data[POST_DATA_LENGTH];
      snprintf(post_data, POST_DATA_LENGTH, "----baswiboundary127\r\n"
                                  "Content-Disposition: form-data; name=\"photo\"; filename=\"photo.jpg\"\r\n"
                                  "Content-Type: image/jpeg\r\n\r\n");
        
      ESP_ERROR_CHECK(esp_http_client_set_url(client, "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendPhoto?chat_id=573364432"));
      ESP_ERROR_CHECK(esp_http_client_set_method(client, HTTP_METHOD_POST));

      char *boundary = "----baswiboundary127\r\n";
      char *end_boundary = "\r\n----baswiboundary127--\r\n";
      char header[512];
      snprintf(header,512, "multipart/form-data; boundary=--baswiboundary127");
      int total_length = strlen(post_data) + fb->len + strlen(end_boundary); //length of pre_data+content+end_trailer
      ESP_LOGI(TAG, "total length= %d", total_length);
      esp_http_client_set_header(client, "Content-Type", header);
      err = esp_http_client_open(client, total_length); //2nd param is use in "Content-Length: (wireshark); 
      //source: client_open->client_request_send: sends client->request->buffer->data (volgens mij stuurt hij header)
      //source: sets client->request->headers
      //source: open connection and sends header; writes client->request->buffer->data

      if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to open HTTP connection: %s", esp_err_to_name(err));
      } else {
        ESP_LOGI(TAG, "Connection OPENED succesfully");
        int wlen = esp_http_client_write(client, post_data, strlen(post_data));
        // write data to the HTTP connection previously opened by esp_http_client_open
        ESP_LOGI(TAG, "Wrote %d bytes", wlen);
        //do NOT expect HTTP response now, because HTTP message is not yet completely sent
    
        //connection succesfull - send photo in parts   
        //Not usefull for client_write. ESP_ERROR_CHECK(esp_http_client_set_post_field(client, post_data, strlen(post_data)));
        //source: sets client->post_data
        //source: post_data is only send via client_perform
        //source: client_write doet NIKS met post_data gezet via set_post_field
        //source: Je kan local post_data wel als param aan client_write meegeven

        uint8_t *fbBuf = fb->buf;
        size_t fbLen = fb->len;

        uint frame_buffer_index = 0; //next byte to copy from fb to post-data
        uint j;
        for (size_t n=0;n<fbLen;n=n+1024) {
          uint post_data_pos2fil = 0; //next position to write in post_data; reset for each part
          if (n+1024<fbLen) { //not last part, write 1024 bytes from fb to 
            for (j=0; j<1024; j++) {
              post_data[post_data_pos2fil] = fbBuf[frame_buffer_index];
              post_data_pos2fil++;
              frame_buffer_index++;
            }
            ESP_LOGI(TAG, "post_data2fil= %d", post_data_pos2fil); //data itself is binary
            uint wlen = esp_http_client_write(client, post_data, post_data_pos2fil); //not +1, becuase index was already incremented
            ESP_LOGI(TAG, "Wrote %d bytes", wlen);
          }
          else if (fbLen%1024>0) { //remainder is >0, so there is data left
            size_t remainder = fbLen%1024;
            ESP_LOGI(TAG, "remainder= %d", remainder);

            for (j=0; j<remainder; j++) {
              post_data[post_data_pos2fil] = fbBuf[frame_buffer_index];
              post_data_pos2fil++;
              frame_buffer_index++;
            }
            //add last boundary to framebuffer
            strncpy(&post_data[post_data_pos2fil], "\r\n----baswiboundary127--\r\n", strlen("\r\n----baswiboundary127--\r\n"));
            post_data_pos2fil += strlen("\r\n----baswiboundary127--\r\n"); //adapt index due to previous line
          
            ESP_LOGI(TAG, "LAST PART - post_data2fil= %d", post_data_pos2fil);
            uint wlen = esp_http_client_write(client, post_data, post_data_pos2fil); //post_data2fil=next pos to fil=equal length filled
            ESP_LOGI(TAG, "Wrote %d bytes", wlen);

            int data_read = esp_http_client_read_response(client, output_buffer, MAX_HTTP_OUTPUT_BUFFER);
            if (data_read >= 0) {
              ESP_LOGI(TAG, "HTTP GET Status = %d, content_length = %d",
              esp_http_client_get_status_code(client),
              esp_http_client_get_content_length(client));
            } else {
              ESP_LOGE(TAG, "Failed to read response");
            }
          }
        } //for - all parts sent */
        esp_camera_fb_return(fb);//@@@can be optimised; this buffer can be released much sooner, so other call to this function
        esp_http_client_cleanup(client);
        sendAlert2Telegram = false;
      }
    }
    // do not send alerts faster than every x seconds, and yield OS
    vTaskDelay(20000/portTICK_PERIOD_MS); 
  }
}


static void task_handle_button_interrupt(void *pvParameter) {
  ESP_LOGI(TAG, "Debounced ButtonRead Task running on core: %d ", xPortGetCoreID());
  uint32_t io_num;

  for(;;) {
    if(xQueueReceive(gpio_evt_button_queue, &io_num, portMAX_DELAY) == pdTRUE) {
      ESP_LOGI(TAG, "button interrupt received");
      //@@@xTaskCreate((TaskFunction_t)&task_ssd1306_display_text, "ssd1306_display_text",  2048,
      //@@@       		  (void *)"DING        \nDONG        \n", 6, NULL);
      //ring the bell
      //esp_http_client_handle_t http_client = esp_http_client_init(&http_config); //seems that client_init once is not enought; maybe the 
      
      sendAlert2Telegram = true;
      
      vTaskDelay(400/portTICK_PERIOD_MS); //wait 400 msec, then enable interrupts again
      gpio_intr_enable(BUTTON_GPIO);
    }
  }
}

static void task_handle_PIR_interrupt(void *pvParameter) {
  ESP_LOGI(TAG, "Debounced PIR read Task running on core: %d ", xPortGetCoreID());
  uint32_t io_num;

  for(;;) {
    if(xQueueReceive(gpio_evt_PIR_queue, &io_num, portMAX_DELAY) == pdTRUE) {
      ESP_LOGI(TAG, "PIR interrupt received");
      sendAlert2Telegram = true;
      vTaskDelay(10000/portTICK_PERIOD_MS); //wait 10000 msec, then enable interrupts again
      gpio_intr_enable(PIR_PIN);
    }
  }
}


/*        ESP_LOGI(TAG, "Taking picture...");  //not necessary anymore, because of streaming webserver
        // put delay so that wdg can be fed
        vTaskDelay(100/portTICK_PERIOD_MS);
        // take photo and send 2 telegram
        camera_fb_t * fb = NULL;
        fb = esp_camera_fb_get();  
        if(!fb) {
          ESP_LOGE(TAG, "Camera capture failed");
          return;
        }
*/
        // POST
        //const char *post_data = "{\"field1\":\"value1\"}";
        //const char *post_data = "/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendPhoto?chat_id=573364432&photo=https://homepages.cae.wisc.edu/~ece533/images/airplane.png";
        //const char *post_data = "/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendMessage?chat_id=573364432&text=HelloBas"            
        //WORKS esp_http_client_set_url(client, "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendMessage?chat_id=573364432&text=HelloBas");
        /* WORKS esp_http_client_set_url(client, "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendPhoto?chat_id=573364432&photo=https://homepages.cae.wisc.edu/~ece533/images/airplane.png");
        esp_http_client_set_method(client, HTTP_METHOD_POST);
        esp_http_client_set_header(client, "Content-Type", "application/json");
        esp_http_client_set_post_field(client, post_data, strlen(post_data)); */

//WORKS - send TXt DOCUMENT 
/*        esp_err_t err;
        err = esp_http_client_set_url(client, "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendDocument?chat_id=573364432");
        ESP_LOGI(TAG, "SET URL return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));
        
        esp_http_client_set_method(client, HTTP_METHOD_POST);
        ESP_LOGI(TAG, "SET METHOD return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));

        //baswi create header
        char header[512];
        snprintf(header,512, "multipart/form-data; boundary=--baswi127");
        ESP_LOGI(TAG, "baswi header= %s", header);
        err = esp_http_client_set_header(client, "Content-Type", header);
        ESP_LOGI(TAG, "SET HEADER return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));
        
        const char *post_data =   "----baswi127\r\n"
                                  "Content-Disposition: form-data; name=\"document\"; filename=\"Testimage.txt\"\r\n"
                                  "Content-Type: text/plain\r\n\r\n"
                                  "inhoud van het bestand"
                                  "\r\n"
                                  "----baswi127--"
                                  "\r\n";
        ESP_LOGI(TAG, "DATA= %s", post_data);
        ESP_LOGI(TAG, "data length= %d", strlen(post_data));
        err = esp_http_client_set_post_field(client, post_data, strlen(post_data));
        ESP_LOGI(TAG, "SET POST FIELD return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));
*/

/* Now try to send photo
        //esp_err_t err;
        err = esp_http_client_set_url(client, "https://api.telegram.org/bot674653520:AAERJg5chmEQyJRpQhG2Bpg-enFVUSAMNsI/sendPhoto?chat_id=573364432");
        ESP_LOGI(TAG, "SET URL return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));
        
        esp_http_client_set_method(client, HTTP_METHOD_POST);
        ESP_LOGI(TAG, "SET METHOD return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));

        //baswi create header
        char header[512];
        snprintf(header,512, "multipart/form-data; boundary=--baswi127");
        ESP_LOGI(TAG, "baswi header= %s", header);
        err = esp_http_client_set_header(client, "Content-Type", header);
        ESP_LOGI(TAG, "SET HEADER return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));
        
        
        char post_data[2500] =   "----baswi127\r\n"
                                  "Content-Disposition: form-data; name=\"photo\"; filename=\"photo.jpg\"\r\n"
                                  "Content-Type: image/jpeg\r\n\r\n";
                                  //"inhoud van het bestand"
                                  //"\r\n"
                                  //"----baswi127--"
                                  //"\r\n";
        uint i=strlen(post_data);
        uint fb_index = 0;
        ESP_LOGI(TAG, "framebufer has size: %d", framebuffer_len);
        while (i<2000)
        { //framebuffer is set in capture_handler
            post_data[i] = framebuffer[fb_index];
            i++;
            fb_index++;
        } //POST: post_data contains preamble and picture
        const char* after_file_contents = "\r\n----baswi127--\r\n";
        strcat(post_data, after_file_contents);

        //ESP_LOGI(TAG, "DATA= %s", post_data); //picture contains non=printable characters
        ESP_LOGI(TAG, "data length= %d", strlen(post_data));
        err = esp_http_client_set_post_field(client, post_data, strlen(post_data));
        ESP_LOGI(TAG, "SET POST FIELD return-value = %d, descr = %s",
                 err,
                 esp_err_to_name(err));

        err = esp_http_client_perform(client);


        if (err == ESP_OK) {
          ESP_LOGI(TAG, "HTTP POST Status = %d, content_length = %d",
                   esp_http_client_get_status_code(client),
                   esp_http_client_get_content_length(client));
          ESP_LOGI(TAG, "baswi response= %s",local_response_buffer); //geeft extra info over error
        } else {
          ESP_LOGE(TAG, "HTTP POST request failed: %s", esp_err_to_name(err));
        }
        esp_http_client_cleanup(client); */


httpd_handle_t camera_httpd = NULL;
char the_page[4000];

static esp_err_t capture_handler(httpd_req_t *req) {
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  char fname[100];
  int file_number = 0;

  ESP_LOGI(TAG, "capture, core: %d ", xPortGetCoreID());
  ESP_LOGI(TAG, "priority = %d", uxTaskPriorityGet(NULL));

  file_number++;

  ESP_LOGI(TAG, "fname, inline; filename=capture_%d.jpg", file_number);

  fb = esp_camera_fb_get();
  framebuffer_len = fb->len;
  memcpy(framebuffer, fb->buf, framebuffer_len);
  esp_camera_fb_return(fb);

  httpd_resp_set_type(req, "image/jpeg");
  httpd_resp_set_hdr(req, "Content-Disposition", fname);

  res = httpd_resp_send(req, (const char *)framebuffer, framebuffer_len);

  return res;
}


static esp_err_t index_handler(httpd_req_t *req) {
//  Serial.print("http index, core ");  Serial.print(xPortGetCoreID());
//  Serial.print(", priority = "); Serial.println(uxTaskPriorityGet(NULL));

  time(&now);
  const char *strdate = ctime(&now);

//baswi PROGMEM removed - arduino specific
  const char msg[] = R"(<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>%s ESP32-CAM Video Recorder</title>
</head>
<body>
<h1>Camera streamer <br><font color="red">%s</font></h1><br>
 Framesize %d, Quality %d <br>
 <br>
 <h3><a href="http://%s/stream">Stream at 5 fps </a></h3>
 <h3><a href="http://%s/photos">Photos - 15 saveable photos @ every 2 seconds </a></h3>
</body>
</html>)";

  sprintf(the_page, msg, devname, strdate,
          camera_config.frame_size, camera_config.jpeg_quality,
          localip, localip); 

  httpd_resp_send(req, the_page, strlen(the_page));
  return ESP_OK;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//
static esp_err_t photos_handler(httpd_req_t *req) {

  //Serial.print("http photos, core ");  Serial.print(xPortGetCoreID());
  //Serial.print(", priority = "); Serial.println(uxTaskPriorityGet(NULL));

  time(&now);
  const char *strdate = ctime(&now);

  const char msg[] = R"(<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>%s ESP32-CAM Video Recorder Junior</title>
</head>
<body>
<h1>%s<br>ESP32-CAM Video Recorder <br><font color="red">%s</font></h1><br>
 <br>
 One photo every 2 seconds for 30 seconds - roll forward or back - refresh for more live photos
 <br>
<br><div id="image-container"></div>
<script>
document.addEventListener('DOMContentLoaded', function() {
  var c = document.location.origin;
  const ic = document.getElementById('image-container');  
  var i = 1;
  
  var timing = 2000; // time between snapshots for multiple shots
  function loop() {
    ic.insertAdjacentHTML('beforeend','<img src="'+`${c}/capture?_cb=${Date.now()}`+'">')
    ic.insertAdjacentHTML('beforeend','<br>')
    ic.insertAdjacentHTML('beforeend',Date())
    ic.insertAdjacentHTML('beforeend','<br>')
    i = i + 1;
    if ( i <= 15 ) {             // 1 frame every 2 seconds for 15 seconds 
      window.setTimeout(loop, timing);
    }
  }
  loop();
  
})
</script><br>
</body>
</html>)";

  sprintf(the_page, msg, devname, devname, strdate );

  httpd_resp_send(req, the_page, strlen(the_page));
  return ESP_OK;
}

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
//  Streaming stuff based on Random Nerd
//
//

#define PART_BOUNDARY "123456789000000000000987654321"

static const char* _STREAM_CONTENT_TYPE = "multipart/x-mixed-replace;boundary=" PART_BOUNDARY;
static const char* _STREAM_BOUNDARY = "\r\n--" PART_BOUNDARY "\r\n";
static const char* _STREAM_PART = "Content-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n";

static esp_err_t stream_handler(httpd_req_t *req) {
  camera_fb_t * fb = NULL;
  esp_err_t res = ESP_OK;
  size_t _jpg_buf_len = 0;
  uint8_t * _jpg_buf = NULL;
  char * part_buf[64];

  //Serial.print("stream_handler, core ");  Serial.print(xPortGetCoreID());
  //Serial.print(", priority = "); Serial.println(uxTaskPriorityGet(NULL));

  res = httpd_resp_set_type(req, _STREAM_CONTENT_TYPE);
  if (res != ESP_OK) {
    return res;
  }

  while (true) {
    fb = esp_camera_fb_get(); //@@@crashes in this function sometimes; only if OLED display is used??
    framebuffer_len = fb->len;
    memcpy(framebuffer, fb->buf, framebuffer_len);
    esp_camera_fb_return(fb);

    _jpg_buf_len = framebuffer_len;
    _jpg_buf = framebuffer;

    size_t hlen = snprintf((char *)part_buf, 64, _STREAM_PART, _jpg_buf_len);
    res = httpd_resp_send_chunk(req, (const char *)part_buf, hlen);
    if (res != ESP_OK) {
      return res;
    }

    res = httpd_resp_send_chunk(req, (const char *)_jpg_buf, _jpg_buf_len);
    if (res != ESP_OK) {
      return res;
    }

    res = httpd_resp_send_chunk(req, _STREAM_BOUNDARY, strlen(_STREAM_BOUNDARY));
    if (res != ESP_OK) {
      return res;
    }
    vTaskDelay(200/portTICK_PERIOD_MS);      // 200 ms = 5 fps !!!
  }
  return res;
}

void startCameraServer() {
  httpd_config_t config = HTTPD_DEFAULT_CONFIG();

  ESP_LOGI(TAG, "http task prio: %d", config.task_priority);

  httpd_uri_t index_uri = {
    .uri       = "/",
    .method    = HTTP_GET,
    .handler   = index_handler,
    .user_ctx  = NULL
  };
  httpd_uri_t capture_uri = {
    .uri       = "/capture",
    .method    = HTTP_GET,
    .handler   = capture_handler,
    .user_ctx  = NULL
  };
  httpd_uri_t stream_uri = {
    .uri       = "/stream",
    .method    = HTTP_GET,
    .handler   = stream_handler,
    .user_ctx  = NULL
  };  
  httpd_uri_t photos_uri = {
    .uri       = "/photos",
    .method    = HTTP_GET,
    .handler   = photos_handler,
    .user_ctx  = NULL
  };

  if (httpd_start(&camera_httpd, &config) == ESP_OK) {
    httpd_register_uri_handler(camera_httpd, &index_uri);
    httpd_register_uri_handler(camera_httpd, &capture_uri);
    httpd_register_uri_handler(camera_httpd, &stream_uri);
    httpd_register_uri_handler(camera_httpd, &photos_uri);
  }
  ESP_LOGI(TAG, "Camera http started");
}

extern "C" {
   void app_main();
}

void app_main()
{
  //esp_log_level_set(TAG, ESP_LOG_NONE); //turn OFF logging
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);
  ESP_ERROR_CHECK(esp_netif_init());
  ESP_ERROR_CHECK(esp_event_loop_create_default());

  /* This helper function configures Wi-Fi or Ethernet, as selected in menuconfig.
   * Read "Establishing Wi-Fi or Ethernet Connection" section in
   * examples/protocols/README.md for more information about this function.
   */
  ESP_ERROR_CHECK(example_connect());
  sprintf(localip, "192.168.1.164"); //@@@should not be hard coded
  ESP_LOGI(TAG, "Connected to AP");

    struct tm timeinfo;
  time(&now);
  localtime_r(&now, &timeinfo);
  // Is time set? If not, tm_year will be (1970 - 1900).
  if (timeinfo.tm_year < (2022 - 1900)) {
    ESP_LOGI(TAG, "Time is not set yet. Connecting to WiFi and getting time over NTP.");
    obtain_time();
    // update 'now' variable with current time
    time(&now);
  }

  char strftime_buf[64];
  // Set timezone 
  setenv("TZ", ":Europe/Amsterdam", 1);
  tzset();
  localtime_r(&now, &timeinfo);
  strftime(strftime_buf, sizeof(strftime_buf), "%c", &timeinfo);
  ESP_LOGI(TAG, "The current date/time in Amsterdam is: %s", strftime_buf);


//  wifi_event_group = xEventGroupCreate();
//  initialise_wifi();
//  xTaskCreate(&printWiFiIP,"printWiFiIP",2048,NULL,5,NULL);
  //***END WIFI

  //i2c_master_init(); no needed???@@@
  init_camera();  //must be executed before i2c_master_init; otherwise init_camera fails
  vTaskDelay(500/portTICK_PERIOD_MS);
  // init Oled1306 display
	//ssd1306_init();
    /* Select the font to use with menu and all font functions
    ssd1306_setFixedFont(ssd1306xled_font6x8);

    ssd1306_128x64_i2c_init();
    ssd1306_clearScreen();

    ssd1306_setFixedFont(ssd1306xled_font6x8);
    ssd1306_clearScreen();
    ssd1306_printFixed(0,  8, "Normal text", STYLE_NORMAL);
    ssd1306_printFixed(0, 16, "Bold text", STYLE_BOLD);
    ssd1306_printFixed(0, 24, "Italic text", STYLE_ITALIC);
    ssd1306_negativeMode();
    ssd1306_printFixed(0, 32, "Inverted bold", STYLE_BOLD);
    ssd1306_positiveMode();
*/
  //esp_http_client_handle_t http_client = esp_http_client_init(&http_config);
  
	//@@@xTaskCreate(&task_ssd1306_display_clear_baswi, "ssd1306_display_clear_baswi",  2048, NULL, 6, NULL);
	vTaskDelay(100/portTICK_PERIOD_MS);
	//@@@xTaskCreate((TaskFunction_t)&task_ssd1306_display_text, "ssd1306_display_text",  2048,
	//@@@	(void *)"Fam.          \naan de Wiel\n\nZadkinestraat\n126\n", 6, NULL);
  xTaskCreate((TaskFunction_t)&task_sendAlert2Telegram, "task_sendAlert2Telegram",  8096,
          		  NULL, 5, NULL);
 
  //Configure button
  gpio_reset_pin(BUTTON_GPIO);
  gpio_config_t btn_config;
  btn_config.mode = GPIO_MODE_INPUT;        	//Set as Input
  btn_config.intr_type = GPIO_INTR_LOW_LEVEL; 
  btn_config.pin_bit_mask = (1 << BUTTON_GPIO); //Bitmask
  //btn_config.pin_bit_mask = ((1 << BUTTON_GPIO) | (1 << PIR_PIN)); //Bitmask
  btn_config.pull_up_en = GPIO_PULLUP_DISABLE; 	
  btn_config.pull_down_en = GPIO_PULLDOWN_ENABLE; //Enable pulldown
  gpio_config(&btn_config);
  ESP_LOGI(TAG, "Button configured\n");
  

  //configure PIR
  btn_config.mode = GPIO_MODE_INPUT;        	//Set as Input
  btn_config.intr_type = GPIO_INTR_HIGH_LEVEL; 
  btn_config.pin_bit_mask = (1 << PIR_PIN); //Bitmask
  //btn_config.pin_bit_mask = ((1 << BUTTON_GPIO) | (1 << PIR_PIN)); //Bitmask
  btn_config.pull_up_en = GPIO_PULLUP_DISABLE; 	
  btn_config.pull_down_en = GPIO_PULLDOWN_ENABLE; 
  gpio_config(&btn_config);

  //create a queue to handle BUTTON intr from isr
  gpio_evt_button_queue = xQueueCreate(1, sizeof(uint32_t));
  //create a queue to handle PIR intr from isr //must be separate queues, because separate task are called; otherwise fi button taksk
  //could get PIR-interrupt out of the queue, without re-enabling the PIR interrupt.
  gpio_evt_PIR_queue = xQueueCreate(1, sizeof(uint32_t));

//3jan; remove pinnedtocore
//  xTaskCreatePinnedToCore(&task_handle_button_interrupt, "task_handle_button_interrupt", 8000, NULL, 5, NULL, APP_CPU_NUM);
//  xTaskCreatePinnedToCore(&task_handle_PIR_interrupt, "task_handle_PIR_interrupt", 8000, NULL, 5, NULL, APP_CPU_NUM);
// 3jan lowered prio from 5 to 3
  xTaskCreate(&task_handle_button_interrupt, "task_handle_button_interrupt", 8000, NULL, 3, NULL);
  xTaskCreate(&task_handle_PIR_interrupt, "task_handle_PIR_interrupt", 8000, NULL, 3, NULL);

  //Configure interrupt and add handler
  gpio_install_isr_service(0);						//Start Interrupt Service Routine service
    
  ret = gpio_isr_handler_add(BUTTON_GPIO, (gpio_isr_t)handleButtonInterrupt, NULL); //debouncing version
  if(ret != ESP_OK ){
      ESP_LOGE(TAG,"gpio_isr_handler_add failed:%d",ret);  
    }
  ESP_LOGI(TAG, "Button Interrupt configured\n");

  ret = gpio_isr_handler_add(PIR_PIN, (gpio_isr_t)handlePIRInterrupt, NULL); //debouncing version
  if(ret != ESP_OK ){
      ESP_LOGE(TAG,"gpio_isr_handler_add failed:%d",ret);  
    }
  ESP_LOGI(TAG, "PIR Interrupt configured\n");

//  startCameraServer(); //camera streaming server; IF active, most photo's do not arrive at Telegram
//baswi replaced ps_malloc by malloc; so probably not in PSRAM, seen https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-guides/external-ram.html
//baswi remove type cast from (uint8_t*)malloc
  framebuffer = (uint8_t*)malloc(size_t(512 * 1024)); // buffer to store a jpg in motion

  ESP_LOGI(TAG, "  End of setup()\n\n");
}

static void obtain_time(void)
{
    /* This helper function configures Wi-Fi or Ethernet, as selected in menuconfig.
     * Read "Establishing Wi-Fi or Ethernet Connection" section in
     * examples/protocols/README.md for more information about this function.
     */
    initialize_sntp();

    // wait for time to be set
    time_t now = 0;
    struct tm timeinfo = { 0 };
    int retry = 0;
    const int retry_count = 10;
    while (sntp_get_sync_status() == SNTP_SYNC_STATUS_RESET && ++retry < retry_count) {
        ESP_LOGI(TAG, "Waiting for system time to be set... (%d/%d)", retry, retry_count);
        vTaskDelay(2000 / portTICK_PERIOD_MS);
    }
    time(&now);
    localtime_r(&now, &timeinfo);
}

static void initialize_sntp(void)
{
    ESP_LOGI(TAG, "Initializing SNTP");
    sntp_setoperatingmode(SNTP_OPMODE_POLL);
    sntp_setservername(0, "pool.ntp.org");
    sntp_set_time_sync_notification_cb(time_sync_notification_cb);
    sntp_init();
}
